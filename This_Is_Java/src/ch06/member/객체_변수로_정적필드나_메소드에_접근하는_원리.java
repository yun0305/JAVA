package ch06.member;

public class 객체_변수로_정적필드나_메소드에_접근하는_원리 {

	
	
	/*
	 *인스턴스가 static 멤버에 접근 가능한 이유는 static 멤버가 메모리에 인스턴스와 별개로 존재하기 때문입니다. static 멤버는 클래스 로딩 시점에 메모리에 할당되어 클래스와 함께 메모리의 고정된 위치에 존재하므로, 어떤 인스턴스를 통해서든 접근할 수 있습니다.

		구체적으로 그 원리를 살펴보면 다음과 같습니다.
		
		static 멤버는 클래스 로딩 시점에 메모리에 할당:
		
		자바에서 클래스가 처음 로드될 때, static 필드와 메서드는 클래스 영역(메소드 영역)에 할당됩니다. 이 메모리 영역에 할당된 static 멤버는 프로그램 종료 시까지 유지됩니다.
		즉, 클래스가 로드된 후에는 인스턴스와 관계없이 클래스 이름으로 static 멤버에 접근할 수 있으며, 모든 인스턴스가 동일한 static 멤버를 공유하게 됩니다.
		인스턴스 참조 변수도 클래스의 구조를 알기 때문에 접근 가능:
		
		자바에서 인스턴스를 생성할 때 참조 변수는 해당 클래스의 모든 멤버(필드, 메서드)를 어디에서 가져와야 하는지에 대한 정보를 포함하고 있습니다.
		이때 static 멤버는 클래스에 종속적이라는 정보가 저장되므로, 인스턴스를 통해 접근할 때도 클래스의 static 멤버 위치를 참조하여 값을 가져오거나 메서드를 실행할 수 있습니다.
		static 멤버는 클래스 차원에서 관리됨:
		
		static 멤버는 인스턴스가 몇 개가 생성되든 상관없이 클래스 단위로 관리됩니다. 따라서 특정 인스턴스를 통해 접근하더라도 해당 멤버는 클래스의 static 영역에 위치하게 됩니다.
		요약하면, static 멤버는 클래스에 속하는 정적 멤버이기 때문에, 어떤 인스턴스를 통해서든 static 멤버의 메모리 위치를 참조할 수 있고, 이로 인해 인스턴스가 static 멤버에 접근할 수 있게 됩니다. 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 정적 필드나 메소드를 객체 변수로 불러오는 과정은 자바에서 문법적으로 허용되지만,
	 *  일반적으로 권장되지 않는 방법이다. 그럼에도 불구하고, 객체 변수를 통해 정적 멤버에 접근하는 방법을 설명하겠다.

	정적 필드에 접근하는 경우:

	public class MyClass {
	    public static int staticField = 10;
	}

	public class Main {
	    public static void main(String[] args) {
	        MyClass myObject = new MyClass();
	        int value = myObject.staticField; // 객체 변수를 통해 정적 필드에 접근
	        System.out.println(value); // 출력: 10
	    }
	}
	위의 예시에서는 MyClass라는 클래스의 객체를 생성한 후, myObject.staticField와 같이 객체 변수를 통해 정적 필드에 접근합니다.
	 이 경우, 실제로는 컴파일러가 정적 필드에 접근할 때 클래스 이름을 사용한 접근(MyClass.staticField)으로 변환합니다.
	  컴파일러가 객체 변수를 통한 접근을 허용하기 때문에 이런 방법으로 정적 필드에 접근할 수 있습니다.
	  
	  
	  
	 */
	}






