package ch07.class_extends.Dynamic_Binding;

/*
 * 동적 바인딩은 상속 관계에서만 발생한다 상속 관계가 없는 경우에는 동적 바인딩이 일어날 이유가
 * 없기 때문이다. 동적 바인딩은 부모 클래스의 메소드가 자식 클래스에서 재정의 된 경우에 발생하는
 * 케머니즘이다.
 * 
 * 그래서 동적 바인딩은 재정의 대상에만 적용되고 재정의 대상이 아닌 것들은 모두 정적 바인딩 대상이다.
 * 
 *  <Runtime 시점에서 실행>(JVM이 바이트코드를 실행하는 과정)
 *  	컴파일이 완료된 바이트코드를 JVM이 읽고 실행하는 시점
 *  	프로그램이 실제로 동작하면서 객체의 실제 타입을 기준으로 호출할 메소드를 결정
 * 
 * <동적 바인딩 이란>
 * 		동적 바인딩은 실행 시간에 호출할 메소드를 결정하는 메커니즘이다.
 * 		이는 자바는 다형성을 구현하는 데 핵심적인 역할을 한다.
 * 		
 * 		동적 바인딩은 부모 클래스 타입의 참조 변수가 자식 클래스 객체를 참조할 때 오버라이딩된
 * 		메소드가 객체의 실제 타입에 따라 호출되도록 한다.
 * 
 * 		Runtime
 * 			동적 바인딩 메소드 호출이 실행 시점에 객체의 실제 타입을 기준으로 결정된다
 * 			ex)오버라이딩된 메소드
 * 
 * 동적 바인딩의 원리
 * 		
 * 		1.오버라이딩된 메소드
 * 			부모 클래스에 정의된 메소드가 자식 클래스에서 재정의되었을 때 발생합니다.
 * 
 * 		2.참조 변수의 타입이 아니라 객체의 실제 타입 기준
 * 			호출되는 메소드는 참조 변수의 타입이 아닌 객체의 실제 타입을 기준으로 결정된다.
 * 
 * 		3.JVM의 역할
 * 			JVM은 실행 시점에 객체의 실제 타입을 확인하고, 해당 객체에 맞는 메소드를 호출
 * 	
 * 	정적 메소드일 경우 메소드가 숨겨지고 인스턴스 메소드일 경우 메소드가 재정의된다(어노테이션 없이도)
 * 인스턴스 메소드가 부모의 메소드와 네이밍은 같은데 만약 받는 매개값이 다를경우는 오버로딩된다.
 * 
 * 
 * 
 * 		
 * 			
 * 
 */

public class Child extends Parent {

	String name;//부모의 name은 숨겨진다 부모 name을 꺼내려면 super.name으로 가져오면 됨
	
	Child(){
		System.out.println("child-constructor");
		this.name();
	}
	
	@Override
		public void name() {
			System.out.println("Child mathod");
		}
	
		
}
