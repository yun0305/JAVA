package ch08._interface.default_method;

public interface RemoteControl {

	/*
	 * 인터페이스에는 완전한 실행코드를 가진 디폴트 메소드를 선언할수 있다. 추상 메소드는 실행부가
	 * 없지만 디폴트 메소드는 실행부가 있다. 선언 방법은 클래스 메소드와 동일한데, 차이점은 
	 * default가 붙는다는 것이다.
	 * 
	 * 예시)[public] default 리턴타입 메소드명(매개변수,...){...}
	 * 디폴트 메소드의 실행부에는 상수 필드를 읽거나 추상 메소드를 호출하는 코드를 작성할수 있다.
	 * RemoteControl 인터페이스에서 무음처리 기능 setMute() 디폴트 메소드를 정의해 보자.
	 */
	
	//상수 필드
	int MAX_VOLUME = 10;
	int MIN_VOLUME = 0;
	
	//추상 메소드
	void trunOn();
	void trunOff();
	void setVolume(int Volume);
	int getVolume();
	
	//디폴트 메소드
	
	/*
	 * 여기서 중요한건 디폴트 메소드가 왜 필요하냐는 거다 인터페이스로는 객체를 생성할수도 없고 인터페이스 안에
	 * 메소드를 사용할수도 없다 인터페이스는 단지 설명서이다 내가 사용할 구현 객체들은 기본적으로 이러한 기능들을 가지고
	 * 있을 것이다 라는 설명서이다 인터페이스는 구현객체가 있어야 사용할수 있다
	 * 이제 사용하는 이유를 설명할 것이다 
	 * 모든 구현객체가 같은 실행 결과와 동작을 하는 메소드를 가지고 있다면 인터페이스에 한번 작성해 놓고
	 * 사용하려고 만든 메소드다 선언은 인터페이스에 했지만 소속은 구현객체이다
	 * 
	 * 디폴트 메소드는 구현 객체가 필요한 메소드이다. 따라서 RemoteControl의 setMute()메소드를 호출하려면 구현객체인
	 * Television 객체를 다음과 같이 인터페이스 변수에 대입하고 나서 setMute()를 호출 해야한다.
	 */
		default void setMute(boolean mute) {//모든 구현 객체가 가지는 기본 메소드
		/* 다시한번 디폴트 메소드는 구현객체가 있어야 사용할수 있다. 모든 구현객체의 기본 메소드이다
		 * 그래서 default 메소드이다.
		 */
		if(mute) {
			System.out.println("무음처리 합니다");
			//추상 메소드 호출하면서 상수 필드 사용
			setVolume(MIN_VOLUME);
		}
		
		else {
			System.out.println("무음을 해제합니다");
		}
	}
	
}
//사용 이유

/*자바8에서 인터페이스에 왜 default 메소드가 추가되었는지 그 이유는 꽤 명확합니다.

추상에 기반한 디자인에 따르면 인터페이스는 일반적으로 하나 혹은 다수의 구현 클래스들을 가지고 있는데
만약 인터페이스에 새로운 추상 메소드가 추가된다면 그 추가된 수 만큼 구현 클래스들은 강제적으로 구현을 해야합니다.
그렇지 않으면 이 디자인은 바로 무너져 내립니다.

인터페이스의 default 메소드는 이 이슈를 효율적으로 해결할 수 있습니다.
그것들은 인터페이스에 새로운 메소드가 추가되면 자동적으로 구현 클래스에서도 사용할 수 있게 됩니다.
즉, 구현 클래스들을 수정할 필요가 없어집니다.

이렇게 구현 클래스를 수정하지 않고 깔끔하게 하위 호환(backward compatibility)이 가능하게 합니다.
*/